<!doctype html>
<html lang="en" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Newton's Physics Simulator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="/_sdk/element_sdk.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&amp;family=Outfit:wght@300;400;600;700&amp;display=swap" rel="stylesheet">
  <style>
    body {
      box-sizing: border-box;
    }
    * {
      font-family: 'Outfit', sans-serif;
    }
    .mono {
      font-family: 'Space Mono', monospace;
    }
    canvas {
      display: block;
    }
    .control-btn {
      transition: all 0.2s ease;
    }
    .control-btn:hover {
      transform: translateY(-2px);
    }
    .control-btn:active {
      transform: translateY(0);
    }
    .glow {
      box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
    }
    .stat-card {
      backdrop-filter: blur(10px);
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full m-0 p-0 overflow-hidden">
  <div id="app-container" class="h-full w-full flex flex-col" style="background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%);"><!-- Header -->
   <header class="flex flex-col lg:flex-row items-start lg:items-center justify-between px-4 lg:px-6 py-3 lg:py-4 border-b border-indigo-500/20 gap-2 lg:gap-0">
    <div>
     <h1 id="title" class="text-lg lg:text-2xl font-bold text-white tracking-tight">Newton's Physics Simulator</h1>
     <p id="instructions" class="text-indigo-300 text-xs lg:text-sm mt-1">Click to spawn ‚Ä¢ Drag to throw</p>
    </div>
    <div class="flex items-center gap-2 lg:gap-3 w-full lg:w-auto">
     <div class="stat-card bg-indigo-500/10 border border-indigo-500/30 rounded-lg px-3 lg:px-4 py-2 flex-1 lg:flex-none"><span class="text-indigo-300 text-xs uppercase tracking-wider block">Objects</span>
      <p id="ball-count" class="text-white font-bold mono text-sm lg:text-lg">0</p>
     </div>
     <div class="stat-card bg-emerald-500/10 border border-emerald-500/30 rounded-lg px-3 lg:px-4 py-2 flex-1 lg:flex-none"><span class="text-emerald-300 text-xs uppercase tracking-wider block">Energy</span>
      <p id="total-energy" class="text-white font-bold mono text-sm lg:text-lg">0 J</p>
     </div>
    </div>
   </header><!-- Main Content -->
   <div class="flex-1 flex flex-col lg:flex-row overflow-hidden"><!-- Canvas Area -->
    <div class="flex-1 relative order-1 lg:order-none">
     <canvas id="physics-canvas" class="w-full h-full"></canvas><!-- Velocity indicator -->
     <div id="velocity-indicator" class="absolute hidden pointer-events-none">
      <svg width="100" height="100" class="overflow-visible"><defs>
        <marker id="arrowhead" markerwidth="10" markerheight="7" refx="9" refy="3.5" orient="auto">
         <polygon points="0 0, 10 3.5, 0 7" fill="#f472b6" />
        </marker>
       </defs> <line id="velocity-line" x1="50" y1="50" x2="50" y2="50" stroke="#f472b6" stroke-width="3" marker-end="url(#arrowhead)" />
      </svg>
     </div>
    </div><!-- Control Panel -->
    <aside class="w-full lg:w-80 bg-slate-900/50 border-l border-indigo-500/20 p-3 lg:p-5 flex flex-col gap-2 lg:gap-4 overflow-y-auto max-h-64 lg:max-h-none order-2 lg:order-none border-t lg:border-t-0 border-indigo-500/20"><!-- Gravity Control -->
     <div class="bg-slate-800/50 rounded-xl p-3 lg:p-4 border border-slate-700/50"><label class="text-indigo-300 text-xs uppercase tracking-wider font-semibold flex items-center gap-2">
       <svg class="w-3 lg:w-4 h-3 lg:h-4" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
       </svg> Gravity </label> <input type="range" id="gravity-slider" min="0" max="50" value="9.8" step="0.1" class="w-full mt-2 lg:mt-3 accent-indigo-500">
      <div class="flex justify-between mt-1 lg:mt-2 text-xs lg:text-sm"><span class="text-slate-400">0</span> <span id="gravity-value" class="text-white mono font-bold">9.8 m/s¬≤</span> <span class="text-slate-400">50</span>
      </div>
     </div><!-- Friction Control -->
     <div class="bg-slate-800/50 rounded-xl p-4 border border-slate-700/50"><label class="text-amber-300 text-xs uppercase tracking-wider font-semibold flex items-center gap-2">
       <svg class="w-4 h-4" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
       </svg> Air Friction </label> <input type="range" id="friction-slider" min="0" max="100" value="2" class="w-full mt-3 accent-amber-500">
      <div class="flex justify-between mt-2"><span class="text-slate-400 text-xs">0%</span> <span id="friction-value" class="text-white mono text-sm font-bold">2%</span> <span class="text-slate-400 text-xs">100%</span>
      </div>
     </div><!-- Restitution Control -->
     <div class="bg-slate-800/50 rounded-xl p-4 border border-slate-700/50"><label class="text-emerald-300 text-xs uppercase tracking-wider font-semibold flex items-center gap-2">
       <svg class="w-4 h-4" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
       </svg> Bounciness </label> <input type="range" id="restitution-slider" min="0" max="100" value="80" class="w-full mt-3 accent-emerald-500">
      <div class="flex justify-between mt-2"><span class="text-slate-400 text-xs">0%</span> <span id="restitution-value" class="text-white mono text-sm font-bold">80%</span> <span class="text-slate-400 text-xs">100%</span>
      </div>
     </div><!-- Ball Size Control -->
     <div class="bg-slate-800/50 rounded-xl p-4 border border-slate-700/50"><label class="text-pink-300 text-xs uppercase tracking-wider font-semibold flex items-center gap-2">
       <svg class="w-4 h-4" fill="currentColor" viewbox="0 0 24 24"><circle cx="12" cy="12" r="10" />
       </svg> Ball Size </label> <input type="range" id="size-slider" min="10" max="60" value="25" class="w-full mt-3 accent-pink-500">
      <div class="flex justify-between mt-2"><span class="text-slate-400 text-xs">10px</span> <span id="size-value" class="text-white mono text-sm font-bold">25px</span> <span class="text-slate-400 text-xs">60px</span>
      </div>
     </div><!-- Advanced Features -->
     <div class="bg-gradient-to-br from-purple-500/10 to-pink-500/10 rounded-xl p-4 border border-purple-500/30"><label class="text-purple-300 text-xs uppercase tracking-wider font-semibold flex items-center gap-2 mb-3">
       <svg class="w-4 h-4" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
       </svg> Advanced Features </label>
      <div class="space-y-3"><label class="flex items-center gap-3 cursor-pointer hover:bg-purple-500/20 p-2 rounded transition"> <input type="checkbox" id="gravity-well-toggle" class="w-4 h-4 accent-purple-500"> <span class="text-slate-300 text-sm">Gravity Wells</span> </label> <label class="flex items-center gap-3 cursor-pointer hover:bg-purple-500/20 p-2 rounded transition"> <input type="checkbox" id="magnetic-toggle" class="w-4 h-4 accent-purple-500"> <span class="text-slate-300 text-sm">Magnetic Field</span> </label> <label class="flex items-center gap-3 cursor-pointer hover:bg-purple-500/20 p-2 rounded transition"> <input type="checkbox" id="wind-toggle" class="w-4 h-4 accent-purple-500"> <span class="text-slate-300 text-sm">Wind Force</span> </label> <label class="flex items-center gap-3 cursor-pointer hover:bg-purple-500/20 p-2 rounded transition"> <input type="checkbox" id="grid-toggle" class="w-4 h-4 accent-purple-500" checked> <span class="text-slate-300 text-sm">Show Grid</span> </label> <label class="flex items-center gap-3 cursor-pointer hover:bg-purple-500/20 p-2 rounded transition"> <input type="checkbox" id="trail-toggle" class="w-4 h-4 accent-purple-500" checked> <span class="text-slate-300 text-sm">Show Trails</span> </label>
      </div>
     </div><!-- Wind Control -->
     <div id="wind-control" class="bg-slate-800/50 rounded-xl p-4 border border-slate-700/50 hidden"><label class="text-cyan-300 text-xs uppercase tracking-wider font-semibold flex items-center gap-2">
       <svg class="w-4 h-4" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
       </svg> Wind Strength </label> <input type="range" id="wind-slider" min="-500" max="500" value="0" class="w-full mt-3 accent-cyan-500">
      <div class="flex justify-between mt-2"><span class="text-slate-400 text-xs">‚Üê</span> <span id="wind-value" class="text-white mono text-sm font-bold">0 px/s¬≤</span> <span class="text-slate-400 text-xs">‚Üí</span>
      </div>
     </div><!-- Gravity Well Strength -->
     <div id="gravity-well-control" class="bg-slate-800/50 rounded-xl p-4 border border-slate-700/50 hidden"><label class="text-violet-300 text-xs uppercase tracking-wider font-semibold flex items-center gap-2">
       <svg class="w-4 h-4" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C6.248 6.253 2.25 10.251 2.25 16.253v.003h19.5v-.003c0-6.002-3.997-10-9.75-10z" />
       </svg> Well Strength </label> <input type="range" id="gravity-well-strength" min="1000" max="10000" value="3000" class="w-full mt-3 accent-violet-500">
      <div class="flex justify-between mt-2"><span class="text-slate-400 text-xs">Weak</span> <span id="well-strength-value" class="text-white mono text-sm font-bold">3000</span> <span class="text-slate-400 text-xs">Strong</span>
      </div>
     </div><!-- Preset Scenarios -->
     <div class="bg-gradient-to-br from-emerald-500/10 to-teal-500/10 rounded-xl p-4 border border-emerald-500/30"><label class="text-emerald-300 text-xs uppercase tracking-wider font-semibold flex items-center gap-2 mb-3">
       <svg class="w-4 h-4" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
       </svg> Quick Scenarios </label>
      <div class="space-y-2"><button id="scenario-explosion" class="control-btn w-full bg-emerald-500/20 hover:bg-emerald-500/30 border border-emerald-500/50 text-emerald-300 font-semibold py-2 px-3 rounded-lg text-sm transition-colors"> üí• Explosion </button> <button id="scenario-orbit" class="control-btn w-full bg-cyan-500/20 hover:bg-cyan-500/30 border border-cyan-500/50 text-cyan-300 font-semibold py-2 px-3 rounded-lg text-sm transition-colors"> üåç Orbital System </button> <button id="scenario-collision" class="control-btn w-full bg-pink-500/20 hover:bg-pink-500/30 border border-pink-500/50 text-pink-300 font-semibold py-2 px-3 rounded-lg text-sm transition-colors"> üí• Collision Test </button> <button id="scenario-zero-g" class="control-btn w-full bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/50 text-purple-300 font-semibold py-2 px-3 rounded-lg text-sm transition-colors"> üöÄ Zero Gravity </button>
      </div>
     </div><!-- Advanced Physics Controls -->
     <div class="bg-gradient-to-br from-orange-500/10 to-red-500/10 rounded-xl p-4 border border-orange-500/30"><label class="text-orange-300 text-xs uppercase tracking-wider font-semibold flex items-center gap-2 mb-3">
       <svg class="w-4 h-4" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" />
       </svg> Advanced Physics </label>
      <div class="space-y-3"><label class="flex items-center gap-3 cursor-pointer hover:bg-orange-500/20 p-2 rounded transition"> <input type="checkbox" id="particle-toggle" class="w-4 h-4 accent-orange-500"> <span class="text-slate-300 text-sm">Particle Emitter</span> </label> <label class="flex items-center gap-3 cursor-pointer hover:bg-orange-500/20 p-2 rounded transition"> <input type="checkbox" id="black-hole-toggle" class="w-4 h-4 accent-orange-500"> <span class="text-slate-300 text-sm">Black Hole</span> </label> <label class="flex items-center gap-3 cursor-pointer hover:bg-orange-500/20 p-2 rounded transition"> <input type="checkbox" id="collision-sound-toggle" class="w-4 h-4 accent-orange-500"> <span class="text-slate-300 text-sm">Collision Effects</span> </label> <label class="flex items-center gap-3 cursor-pointer hover:bg-orange-500/20 p-2 rounded transition"> <input type="checkbox" id="energy-loss-toggle" class="w-4 h-4 accent-orange-500" checked> <span class="text-slate-300 text-sm">Energy Loss</span> </label>
      </div>
     </div><!-- Performance Metrics -->
     <div class="bg-gradient-to-br from-blue-500/10 to-indigo-500/10 rounded-xl p-4 border border-blue-500/30">
      <h3 class="text-blue-300 text-xs uppercase tracking-wider font-semibold mb-3 flex items-center gap-2">
       <svg class="w-4 h-4" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
       </svg> Performance</h3>
      <div class="space-y-2 text-slate-300 text-xs">
       <div class="flex justify-between"><span>FPS:</span> <span id="fps-counter" class="text-blue-300 mono font-bold">60</span>
       </div>
       <div class="flex justify-between"><span>Memory:</span> <span id="memory-counter" class="text-blue-300 mono font-bold">0 MB</span>
       </div>
       <div class="flex justify-between"><span>Collisions/frame:</span> <span id="collision-counter" class="text-blue-300 mono font-bold">0</span>
       </div>
      </div>
     </div><!-- Action Buttons -->
     <div class="flex flex-col gap-3 mt-auto"><button id="clear-btn" class="control-btn bg-rose-500/20 hover:bg-rose-500/30 border border-rose-500/50 text-rose-300 font-semibold py-3 px-4 rounded-xl flex items-center justify-center gap-2 transition-colors">
       <svg class="w-5 h-5" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
       </svg> Clear All </button> <button id="pause-btn" class="control-btn bg-indigo-500/20 hover:bg-indigo-500/30 border border-indigo-500/50 text-indigo-300 font-semibold py-3 px-4 rounded-xl flex items-center justify-center gap-2 transition-colors">
       <svg id="pause-icon" class="w-5 h-5" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
       </svg><span id="pause-text">Pause</span> </button>
     </div><!-- Newton's Laws Info -->
     <div class="bg-gradient-to-br from-indigo-500/10 to-purple-500/10 rounded-xl p-4 border border-indigo-500/30">
      <h3 class="text-white font-semibold text-sm mb-3 flex items-center gap-2"><span class="text-lg">üìö</span> Newton's Laws</h3>
      <ul class="text-slate-300 text-xs space-y-2">
       <li><span class="text-indigo-400 font-bold">1st:</span> Objects stay in motion unless acted upon</li>
       <li><span class="text-indigo-400 font-bold">2nd:</span> F = ma (Force = mass √ó acceleration)</li>
       <li><span class="text-indigo-400 font-bold">3rd:</span> Every action has an equal opposite reaction</li>
      </ul>
     </div>
    </aside>
   </div>
  </div>
  <script>
    const defaultConfig = {
      title_text: "Newton's Physics Simulator",
      instructions_text: "Click to spawn balls ‚Ä¢ Drag to throw ‚Ä¢ Watch physics in action!",
      primary_color: "#6366f1",
      secondary_color: "#1e1b4b",
      text_color: "#ffffff",
      accent_color: "#f472b6",
      surface_color: "#1e293b"
    };

    let config = { ...defaultConfig };

    // Physics constants
    let gravityMs2 = 9.8; // Real-world gravity in m/s¬≤
    let friction = 0.02;
    let restitution = 0.8;
    let ballRadius = 25;
    let isPaused = false;

    // Advanced features
    let enableGravityWells = false;
    let enableMagnetic = false;
    let enableWind = false;
    let enableParticles = false;
    let enableBlackHole = false;
    let enableCollisionEffects = false;
    let enableEnergyLoss = true;
    let windStrength = 0;
    let gravityWellStrength = 3000;
    let showGrid = true;
    let showTrails = true;
    let gravitywellCursor = null;
    let blackHolePos = null;
    let collisionsThisFrame = 0;
    let fpsCounter = 0;
    let lastFpsUpdate = 0;
    let frameCount = 0;

    // Ball collection
    const balls = [];
    const colors = ['#f472b6', '#a78bfa', '#60a5fa', '#34d399', '#fbbf24', '#f87171', '#2dd4bf', '#e879f9'];
    const particles = [];

    // Canvas setup
    const canvas = document.getElementById('physics-canvas');
    const ctx = canvas.getContext('2d');
    let canvasRect;

    // Interaction state
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragCurrent = { x: 0, y: 0 };
    let selectedBall = null;

    // DOM elements
    const gravitySlider = document.getElementById('gravity-slider');
    const frictionSlider = document.getElementById('friction-slider');
    const restitutionSlider = document.getElementById('restitution-slider');
    const sizeSlider = document.getElementById('size-slider');
    const clearBtn = document.getElementById('clear-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const velocityIndicator = document.getElementById('velocity-indicator');
    const velocityLine = document.getElementById('velocity-line');

    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      canvasRect = canvas.getBoundingClientRect();
    }

    function createBall(x, y, vx = 0, vy = 0) {
      if (balls.length >= 50) return null;
      
      const ball = {
        id: Date.now() + Math.random(),
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        radius: ballRadius,
        mass: (ballRadius * ballRadius) / 100,
        color: colors[Math.floor(Math.random() * colors.length)],
        trail: [],
        spin: Math.random() * 0.1 - 0.05
      };
      balls.push(ball);
      updateStats();
      return ball;
    }

    function createParticles(x, y, color, count = 8) {
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5;
        const speed = 100 + Math.random() * 200;
        particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          maxLife: 1,
          radius: 2 + Math.random() * 3,
          color: color
        });
      }
    }

    function createExplosion(x, y) {
      if (!enableParticles) return;
      const explosionSize = 12;
      for (let i = 0; i < explosionSize; i++) {
        const ball = createBall(
          x + (Math.random() - 0.5) * 40,
          y + (Math.random() - 0.5) * 40,
          (Math.random() - 0.5) * 800,
          (Math.random() - 0.5) * 800
        );
        if (ball) ball.color = '#fbbf24';
      }
    }

    function updatePhysics(dt) {
      if (isPaused) return;

      const dtSeconds = dt / 1000;
      collisionsThisFrame = 0;

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dtSeconds / p.maxLife;
        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }
        p.vy += gravityMs2 * 100 * dtSeconds; // Convert m/s¬≤ to px/s¬≤
        p.vx *= 0.99;
        p.vy *= 0.99;
        p.x += p.vx * dtSeconds;
        p.y += p.vy * dtSeconds;
      }

      // Update balls
      for (const ball of balls) {
        // Store trail
        if (showTrails) {
          ball.trail.push({ x: ball.x, y: ball.y });
          if (ball.trail.length > 30) ball.trail.shift();
        } else {
          ball.trail = [];
        }

        // Apply gravity (Newton's 2nd Law: F = ma)
        let ay = gravityMs2 * 100; // Convert m/s¬≤ to px/s¬≤

        // Apply wind force
        let ax = 0;
        if (enableWind) {
          ax += windStrength;
        }

        // Apply magnetic field
        if (enableMagnetic) {
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const dx = centerX - ball.x;
          const dy = centerY - ball.y;
          const dist = Math.sqrt(dx * dx + dy * dy) + 1;
          const force = 5000 / (dist + 100);
          ax += (dx / dist) * force * dtSeconds;
          ay += (dy / dist) * force * dtSeconds;
        }

        // Apply black hole (extreme gravity well)
        if (enableBlackHole && blackHolePos) {
          const dx = blackHolePos.x - ball.x;
          const dy = blackHolePos.y - ball.y;
          const distSq = dx * dx + dy * dy;
          const dist = Math.sqrt(distSq) + 1;
          
          if (dist < 500) {
            const force = 50000 / (distSq + 500);
            ax += (dx / dist) * force * dtSeconds;
            ay += (dy / dist) * force * dtSeconds;
          }
        }

        // Apply gravity well at cursor
        if (enableGravityWells && gravitywellCursor) {
          const dx = gravitywellCursor.x - ball.x;
          const dy = gravitywellCursor.y - ball.y;
          const distSq = dx * dx + dy * dy;
          const dist = Math.sqrt(distSq) + 1;
          
          if (dist < 400) {
            const force = gravityWellStrength / (distSq + 1000);
            ax += (dx / dist) * force * dtSeconds;
            ay += (dy / dist) * force * dtSeconds;
          }
        }

        // Apply accelerations
        ball.vx += ax * dtSeconds;
        ball.vy += ay * dtSeconds;

        // Apply air friction
        const speedSq = ball.vx * ball.vx + ball.vy * ball.vy;
        const speed = Math.sqrt(speedSq);
        if (speed > 0) {
          const dragForce = friction * speed;
          const dragAccel = dragForce / ball.mass;
          ball.vx -= (ball.vx / speed) * dragAccel * dtSeconds;
          ball.vy -= (ball.vy / speed) * dragAccel * dtSeconds;
        }

        // Update position
        ball.x += ball.vx * dtSeconds;
        ball.y += ball.vy * dtSeconds;

        // Wall collisions (Newton's 3rd Law: action-reaction)
        let bounced = false;
        if (ball.x - ball.radius < 0) {
          ball.x = ball.radius;
          ball.vx = -ball.vx * restitution;
          bounced = true;
        }
        if (ball.x + ball.radius > canvas.width) {
          ball.x = canvas.width - ball.radius;
          ball.vx = -ball.vx * restitution;
          bounced = true;
        }
        if (ball.y - ball.radius < 0) {
          ball.y = ball.radius;
          ball.vy = -ball.vy * restitution;
          bounced = true;
        }
        if (ball.y + ball.radius > canvas.height) {
          ball.y = canvas.height - ball.radius;
          ball.vy = -ball.vy * restitution;
          bounced = true;
          
          // Ground friction
          ball.vx *= 0.98;
        }

        if (bounced && enableCollisionEffects) {
          createParticles(ball.x, ball.y, ball.color, 4);
        }
      }

      // Ball-to-ball collisions
      for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
          if (handleCollision(balls[i], balls[j])) {
            collisionsThisFrame++;
          }
        }
      }

      updateStats();
    }

    function handleCollision(ball1, ball2) {
      const dx = ball2.x - ball1.x;
      const dy = ball2.y - ball1.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDist = ball1.radius + ball2.radius;

      if (distance < minDist && distance > 0) {
        // Collision normal
        const nx = dx / distance;
        const ny = dy / distance;

        // Relative velocity
        const dvx = ball1.vx - ball2.vx;
        const dvy = ball1.vy - ball2.vy;
        const dvn = dvx * nx + dvy * ny;

        // Don't resolve if balls are separating
        if (dvn > 0) return false;

        // Impulse with optional energy loss
        let e = restitution;
        if (!enableEnergyLoss) {
          e = Math.min(restitution, 1.0);
        }
        const impulse = (-(1 + e) * dvn) / (1 / ball1.mass + 1 / ball2.mass);

        // Apply impulse
        ball1.vx += impulse * nx / ball1.mass;
        ball1.vy += impulse * ny / ball1.mass;
        ball2.vx -= impulse * nx / ball2.mass;
        ball2.vy -= impulse * ny / ball2.mass;

        // Separate balls
        const overlap = minDist - distance;
        const separation = overlap / 2 + 1;
        ball1.x -= nx * separation;
        ball1.y -= ny * separation;
        ball2.x += nx * separation;
        ball2.y += ny * separation;

        if (enableCollisionEffects) {
          createParticles((ball1.x + ball2.x) / 2, (ball1.y + ball2.y) / 2, ball1.color, 6);
        }

        return true;
      }
      return false;
    }

    function render() {
      // Clear canvas completely
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw background
      ctx.fillStyle = '#0f0f1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      if (showGrid) {
        ctx.strokeStyle = 'rgba(99, 102, 241, 0.1)';
        ctx.lineWidth = 1;
        const gridSize = 50;
        for (let x = 0; x < canvas.width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y < canvas.height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
      }

      // Draw black hole
      if (enableBlackHole && blackHolePos) {
        const bhRadius = 60;
        
        // Event horizon glow
        const glowGradient = ctx.createRadialGradient(blackHolePos.x, blackHolePos.y, bhRadius, blackHolePos.x, blackHolePos.y, bhRadius * 3);
        glowGradient.addColorStop(0, 'rgba(139, 92, 246, 0.4)');
        glowGradient.addColorStop(0.5, 'rgba(139, 92, 246, 0.1)');
        glowGradient.addColorStop(1, 'rgba(139, 92, 246, 0)');
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(blackHolePos.x, blackHolePos.y, bhRadius * 3, 0, Math.PI * 2);
        ctx.fill();

        // Black hole center
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.beginPath();
        ctx.arc(blackHolePos.x, blackHolePos.y, bhRadius, 0, Math.PI * 2);
        ctx.fill();

        // Ring
        ctx.strokeStyle = 'rgba(139, 92, 246, 0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(blackHolePos.x, blackHolePos.y, bhRadius, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Draw gravity well indicator
      if (enableGravityWells && gravitywellCursor) {
        ctx.fillStyle = 'rgba(124, 58, 242, 0.1)';
        ctx.beginPath();
        ctx.arc(gravitywellCursor.x, gravitywellCursor.y, 200, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = 'rgba(168, 85, 247, 0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(gravitywellCursor.x, gravitywellCursor.y, 200, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.fillStyle = 'rgba(168, 85, 247, 0.6)';
        ctx.beginPath();
        ctx.arc(gravitywellCursor.x, gravitywellCursor.y, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw magnetic field lines
      if (enableMagnetic) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.15)';
        ctx.lineWidth = 1;
        
        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + Math.cos(angle) * 150,
            centerY + Math.sin(angle) * 150
          );
          ctx.stroke();
        }
        
        ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw wind indicator
      if (enableWind && windStrength !== 0) {
        const arrowSize = 30;
        const startX = windStrength > 0 ? 50 : canvas.width - 50;
        const direction = windStrength > 0 ? 1 : -1;
        
        ctx.strokeStyle = 'rgba(34, 211, 238, 0.4)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(startX, 30);
        ctx.lineTo(startX + direction * arrowSize, 30);
        ctx.stroke();
        
        // Arrow head
        ctx.beginPath();
        ctx.moveTo(startX + direction * arrowSize, 30);
        ctx.lineTo(startX + direction * (arrowSize - 10), 25);
        ctx.lineTo(startX + direction * (arrowSize - 10), 35);
        ctx.closePath();
        ctx.fillStyle = 'rgba(34, 211, 238, 0.6)';
        ctx.fill();
      }

      // Draw particles
      for (const p of particles) {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // Draw balls
      for (const ball of balls) {
        // Draw trail
        if (showTrails && ball.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(ball.trail[0].x, ball.trail[0].y);
          for (let i = 1; i < ball.trail.length; i++) {
            ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
          }
          ctx.strokeStyle = ball.color + '40';
          ctx.lineWidth = ball.radius * 0.5;
          ctx.lineCap = 'round';
          ctx.stroke();
        }

        // Draw ball shadow
        ctx.beginPath();
        ctx.arc(ball.x + 3, ball.y + 3, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fill();

        // Draw ball
        const gradient = ctx.createRadialGradient(
          ball.x - ball.radius * 0.3,
          ball.y - ball.radius * 0.3,
          0,
          ball.x,
          ball.y,
          ball.radius
        );
        gradient.addColorStop(0, ball.color);
        gradient.addColorStop(0.7, ball.color);
        gradient.addColorStop(1, shadeColor(ball.color, -30));

        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Draw highlight
        ctx.beginPath();
        ctx.arc(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fill();

        // Draw velocity vector
        if (!isPaused && (Math.abs(ball.vx) > 50 || Math.abs(ball.vy) > 50)) {
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          const maxArrowLen = 50;
          const arrowLen = Math.min(speed / 10, maxArrowLen);
          const angle = Math.atan2(ball.vy, ball.vx);
          
          ctx.beginPath();
          ctx.moveTo(ball.x, ball.y);
          ctx.lineTo(
            ball.x + Math.cos(angle) * arrowLen,
            ball.y + Math.sin(angle) * arrowLen
          );
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      // Draw paused indicator
      if (isPaused) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 48px Outfit';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('‚è∏ PAUSED', canvas.width / 2, canvas.height / 2);
      }
    }

    function shadeColor(color, percent) {
      const num = parseInt(color.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return '#' + (0x1000000 +
        (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255)
      ).toString(16).slice(1);
    }

    function updateStats() {
      document.getElementById('ball-count').textContent = balls.length;
      
      let totalEnergy = 0;
      for (const ball of balls) {
        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        const kineticEnergy = 0.5 * ball.mass * speed * speed;
        const potentialEnergy = ball.mass * (gravityMs2 * 100 / 100) * (canvas.height - ball.y);
        totalEnergy += kineticEnergy + potentialEnergy;
      }
      
      document.getElementById('total-energy').textContent = Math.round(totalEnergy / 1000) + ' J';
    }

    function getBallAtPosition(x, y) {
      for (let i = balls.length - 1; i >= 0; i--) {
        const ball = balls[i];
        const dx = x - ball.x;
        const dy = y - ball.y;
        if (dx * dx + dy * dy < ball.radius * ball.radius) {
          return ball;
        }
      }
      return null;
    }

    // Event handlers
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      selectedBall = getBallAtPosition(x, y);
      isDragging = true;
      dragStart = { x, y };
      dragCurrent = { x, y };

      if (selectedBall) {
        selectedBall.vx = 0;
        selectedBall.vy = 0;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (enableGravityWells) {
        gravitywellCursor = { x, y };
      }

      if (!isDragging) return;

      dragCurrent = { x, y };

      if (selectedBall) {
        selectedBall.x = dragCurrent.x;
        selectedBall.y = dragCurrent.y;
      } else {
        // Show velocity indicator
        const dx = dragStart.x - dragCurrent.x;
        const dy = dragStart.y - dragCurrent.y;
        
        if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
          velocityIndicator.style.display = 'block';
          velocityIndicator.style.left = (rect.left + dragStart.x - 50) + 'px';
          velocityIndicator.style.top = (rect.top + dragStart.y - 50) + 'px';
          
          velocityLine.setAttribute('x2', 50 + dx * 0.5);
          velocityLine.setAttribute('y2', 50 + dy * 0.5);
        }
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (!isDragging) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (selectedBall) {
        // Throw the ball
        selectedBall.vx = (dragStart.x - x) * 3;
        selectedBall.vy = (dragStart.y - y) * 3;
      } else {
        // Create new ball with velocity
        const vx = (dragStart.x - x) * 3;
        const vy = (dragStart.y - y) * 3;
        createBall(dragStart.x, dragStart.y, vx, vy);
      }

      isDragging = false;
      selectedBall = null;
      velocityIndicator.style.display = 'none';
    });

    canvas.addEventListener('mouseleave', () => {
      if (isDragging && !selectedBall) {
        createBall(dragStart.x, dragStart.y, 0, 0);
      }
      isDragging = false;
      selectedBall = null;
      velocityIndicator.style.display = 'none';
    });

    // Touch events for mobile
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;

      selectedBall = getBallAtPosition(x, y);
      isDragging = true;
      dragStart = { x, y };
      dragCurrent = { x, y };

      if (selectedBall) {
        selectedBall.vx = 0;
        selectedBall.vy = 0;
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!isDragging) return;

      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      dragCurrent = {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      };

      if (selectedBall) {
        selectedBall.x = dragCurrent.x;
        selectedBall.y = dragCurrent.y;
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      if (!isDragging) return;

      if (selectedBall) {
        selectedBall.vx = (dragStart.x - dragCurrent.x) * 3;
        selectedBall.vy = (dragStart.y - dragCurrent.y) * 3;
      } else {
        const vx = (dragStart.x - dragCurrent.x) * 3;
        const vy = (dragStart.y - dragCurrent.y) * 3;
        createBall(dragStart.x, dragStart.y, vx, vy);
      }

      isDragging = false;
      selectedBall = null;
    });

    // Control event listeners
    gravitySlider.addEventListener('input', (e) => {
      gravityMs2 = parseFloat(e.target.value);
      document.getElementById('gravity-value').textContent = gravityMs2 + ' m/s¬≤';
    });

    frictionSlider.addEventListener('input', (e) => {
      friction = parseFloat(e.target.value) / 100;
      document.getElementById('friction-value').textContent = e.target.value + '%';
    });

    restitutionSlider.addEventListener('input', (e) => {
      restitution = parseFloat(e.target.value) / 100;
      document.getElementById('restitution-value').textContent = e.target.value + '%';
    });

    sizeSlider.addEventListener('input', (e) => {
      ballRadius = parseFloat(e.target.value);
      document.getElementById('size-value').textContent = ballRadius + 'px';
    });

    // Advanced feature toggles
    document.getElementById('gravity-well-toggle').addEventListener('change', (e) => {
      enableGravityWells = e.target.checked;
      document.getElementById('gravity-well-control').classList.toggle('hidden', !enableGravityWells);
    });

    document.getElementById('magnetic-toggle').addEventListener('change', (e) => {
      enableMagnetic = e.target.checked;
    });

    document.getElementById('wind-toggle').addEventListener('change', (e) => {
      enableWind = e.target.checked;
      document.getElementById('wind-control').classList.toggle('hidden', !enableWind);
    });

    document.getElementById('grid-toggle').addEventListener('change', (e) => {
      showGrid = e.target.checked;
    });

    document.getElementById('trail-toggle').addEventListener('change', (e) => {
      showTrails = e.target.checked;
    });

    document.getElementById('particle-toggle').addEventListener('change', (e) => {
      enableParticles = e.target.checked;
    });

    document.getElementById('black-hole-toggle').addEventListener('change', (e) => {
      enableBlackHole = e.target.checked;
      if (e.target.checked) {
        blackHolePos = { x: canvas.width / 2, y: canvas.height / 2 };
      } else {
        blackHolePos = null;
      }
    });

    document.getElementById('collision-sound-toggle').addEventListener('change', (e) => {
      enableCollisionEffects = e.target.checked;
    });

    document.getElementById('energy-loss-toggle').addEventListener('change', (e) => {
      enableEnergyLoss = e.target.checked;
    });

    document.getElementById('wind-slider').addEventListener('input', (e) => {
      windStrength = parseFloat(e.target.value);
      document.getElementById('wind-value').textContent = windStrength + ' px/s¬≤';
    });

    document.getElementById('gravity-well-strength').addEventListener('input', (e) => {
      gravityWellStrength = parseFloat(e.target.value);
      document.getElementById('well-strength-value').textContent = e.target.value;
    });

    // Preset scenario buttons
    document.getElementById('scenario-explosion').addEventListener('click', () => {
      balls.length = 0;
      particles.length = 0;
      gravityMs2 = 5;
      enableParticles = true;
      document.getElementById('gravity-slider').value = gravityMs2;
      document.getElementById('gravity-value').textContent = gravityMs2 + ' m/s¬≤';
      document.getElementById('particle-toggle').checked = true;
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      for (let i = 0; i < 20; i++) {
        const angle = (Math.PI * 2 * i) / 20;
        const speed = 300 + Math.random() * 200;
        const ball = createBall(
          centerX + Math.cos(angle) * 30,
          centerY + Math.sin(angle) * 30,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed
        );
        if (ball) ball.color = ['#f472b6', '#fbbf24', '#f87171'][Math.floor(Math.random() * 3)];
      }
    });

    document.getElementById('scenario-orbit').addEventListener('click', () => {
      balls.length = 0;
      particles.length = 0;
      gravityMs2 = 2;
      enableMagnetic = true;
      enableParticles = false;
      windStrength = 0;
      document.getElementById('gravity-slider').value = gravityMs2;
      document.getElementById('gravity-value').textContent = gravityMs2 + ' m/s¬≤';
      document.getElementById('magnetic-toggle').checked = true;
      document.getElementById('particle-toggle').checked = false;
      
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI * 2 * i) / 6;
        const distance = 150 + i * 40;
        const speed = Math.sqrt(5000 / (distance + 100));
        const ball = createBall(
          canvas.width / 2 + Math.cos(angle) * distance,
          canvas.height / 2 + Math.sin(angle) * distance,
          -Math.sin(angle) * speed * 100,
          Math.cos(angle) * speed * 100
        );
        if (ball) ball.radius = 15 - i * 2;
      }
    });

    document.getElementById('scenario-collision').addEventListener('click', () => {
      balls.length = 0;
      particles.length = 0;
      enableParticles = true;
      enableCollisionEffects = true;
      document.getElementById('particle-toggle').checked = true;
      document.getElementById('collision-sound-toggle').checked = true;
      
      const leftBall = createBall(150, canvas.height / 2, 400, 0);
      const rightBall = createBall(canvas.width - 150, canvas.height / 2, -400, 0);
      if (leftBall) leftBall.color = '#60a5fa';
      if (rightBall) rightBall.color = '#f472b6';
    });

    document.getElementById('scenario-zero-g').addEventListener('click', () => {
      balls.length = 0;
      particles.length = 0;
      gravityMs2 = 0;
      enableWind = false;
      enableMagnetic = false;
      enableParticles = false;
      windStrength = 0;
      document.getElementById('gravity-slider').value = gravityMs2;
      document.getElementById('gravity-value').textContent = gravityMs2 + ' m/s¬≤';
      document.getElementById('wind-toggle').checked = false;
      document.getElementById('magnetic-toggle').checked = false;
      document.getElementById('particle-toggle').checked = false;
      
      for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 100 + Math.random() * 200;
        createBall(
          Math.random() * canvas.width,
          Math.random() * canvas.height,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed
        );
      }
    });

    clearBtn.addEventListener('click', () => {
      balls.length = 0;
      particles.length = 0;
      updateStats();
    });

    pauseBtn.addEventListener('click', () => {
      isPaused = !isPaused;
      document.getElementById('pause-text').textContent = isPaused ? 'Resume' : 'Pause';
      document.getElementById('pause-icon').innerHTML = isPaused 
        ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>'
        : '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"/>';
    });

    // Game loop
    let lastTime = 0;
    function gameLoop(timestamp) {
      const dt = Math.min(timestamp - lastTime, 50);
      lastTime = timestamp;
      frameCount++;

      updatePhysics(dt);
      render();

      // Update performance metrics every frame
      if (timestamp - lastFpsUpdate > 1000) {
        fpsCounter = frameCount;
        frameCount = 0;
        lastFpsUpdate = timestamp;
        
        let memoryUsage = 0;
        if (performance.memory) {
          memoryUsage = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
        }
        
        document.getElementById('fps-counter').textContent = fpsCounter;
        document.getElementById('memory-counter').textContent = memoryUsage + ' MB';
        document.getElementById('collision-counter').textContent = collisionsThisFrame;
      }

      requestAnimationFrame(gameLoop);
    }

    // Initialize
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Element SDK integration
    async function onConfigChange(newConfig) {
      document.getElementById('title').textContent = newConfig.title_text || defaultConfig.title_text;
      document.getElementById('instructions').textContent = newConfig.instructions_text || defaultConfig.instructions_text;
    }

    function mapToCapabilities(cfg) {
      return {
        recolorables: [
          {
            get: () => cfg.primary_color || defaultConfig.primary_color,
            set: (v) => { cfg.primary_color = v; window.elementSdk.setConfig({ primary_color: v }); }
          },
          {
            get: () => cfg.secondary_color || defaultConfig.secondary_color,
            set: (v) => { cfg.secondary_color = v; window.elementSdk.setConfig({ secondary_color: v }); }
          },
          {
            get: () => cfg.text_color || defaultConfig.text_color,
            set: (v) => { cfg.text_color = v; window.elementSdk.setConfig({ text_color: v }); }
          },
          {
            get: () => cfg.accent_color || defaultConfig.accent_color,
            set: (v) => { cfg.accent_color = v; window.elementSdk.setConfig({ accent_color: v }); }
          },
          {
            get: () => cfg.surface_color || defaultConfig.surface_color,
            set: (v) => { cfg.surface_color = v; window.elementSdk.setConfig({ surface_color: v }); }
          }
        ],
        borderables: [],
        fontEditable: undefined,
        fontSizeable: undefined
      };
    }

    function mapToEditPanelValues(cfg) {
      return new Map([
        ['title_text', cfg.title_text || defaultConfig.title_text],
        ['instructions_text', cfg.instructions_text || defaultConfig.instructions_text]
      ]);
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities,
        mapToEditPanelValues
      });
      config = window.elementSdk.config || { ...defaultConfig };
      onConfigChange(config);
    }

    // Start simulation
    requestAnimationFrame(gameLoop);

    // Create a few initial balls for demonstration
    setTimeout(() => {
      createBall(200, 100, 150, 0);
      createBall(400, 150, -100, 50);
      createBall(300, 200, 0, -100);
    }, 500);
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9c97090a4356b305',t:'MTc3MDM0MzAzMS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
